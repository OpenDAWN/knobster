#include "pch.h"

char *g_embeddableShaderPaths[] = {
	"pointpassthrough.vert",
	"emitquad.geom",
	"test.frag",
	"ground/ground.vsh",
	"ground/ground.fsh",
	"ground/ground_trans.vsh",
	"ground/ground_trans.fsh",
	"particles.gsh",
	"particles.fsh",
	"simplicity.frag",
	"base.vert",
	"base.frag",
	"envdraw.vert",
	"envdraw.frag",
	"env.frag",
	"particle_draw.vert",
	"particle_draw.frag",
	"particle_init.frag",
	"particle_update.frag",
	"particle_constrain.frag",
	"sky/preetham.vsh",
	"sky/preetham.fsh",
	"sinedistort.frag",
	"blend.frag",
	"vignette.frag",
	"tonemap.frag",
	"lineblur.frag",
	"glowcut.frag",
	"glowcombine.frag",
	"alphaluma.frag",
	"fxaa3_11.frag",
	"passthrough.frag",
	"mssao_downsample.frag",
	"mssao_blur.frag",
	"mssao_first_ao.frag",
	"mssao_ao.frag",
};

uint32_t g_embeddableShaderTypes[] = {
	kVertexShader,
	kGeometryShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kGeometryShader,
	kFragmentShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kVertexShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
	kFragmentShader,
};

char *g_embeddableShaders[] = {
	"#version 330\n"
	"layout(location = 0) in vec4 position;\n"
	"void main()\n"
	"{\n"
	"	gl_Position = position;\n"
	"}\n"
,
	"#version 330 \n"
	"layout(points) in;\n"
	"layout(triangle_strip, max_vertices = 4) out;\n"
	"out vec2 pos;\n"
	"void main()\n"
	"{\n"
	"	vec3 o = vec3(1.0, 0.0, -1.0);\n"
	"	vec4 p = gl_in[0].gl_Position;\n"
	"	gl_Position = p + o.xzyy;\n"
	"	pos = vec2(1.0, 0.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = p + o.xxyy;\n"
	"	pos = vec2(1.0, 1.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = p + o.zzyy;\n"
	"	pos = vec2(0.0, 0.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = p + o.zxyy;\n"
	"	pos = vec2(0.0, 1.0);\n"
	"	EmitVertex();\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform float time;\n"
	"//uniform sampler2D tex;\n"
	"//uniform float angle;\n"
	"//uniform float amplitude;\n"
	"//uniform float frequency;\n"
	"void main()\n"
	"{\n"
	"//	float v = dot(vec2(cos(angle), sin(angle)), pos);\n"
	"//	gl_FragColor = texture2D(tex, pos + vec2(sin(angle), -cos(angle))*amplitude*sin(v*frequency));\n"
	"	gl_FragColor = vec4(pos.x, pos.y, 0.0, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec3 viewNormal;\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"void main()\n"
	"{\n"
	"	mat4 view = vm;\n"
	"	view[3][0] = 0.0;\n"
	"	view[3][1] = 0.0;\n"
	"	view[3][2] = 0.0;\n"
	"	objectPos = pos;\n"
	"	worldPos = mm * pos;\n"
	"	viewPos = view * mm * pos;\n"
	"	\n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	gl_Position = pm * view * mm * pos;\n"
	"	//gl_Position = pm * (pos + vec4(0.0, 0.0, -10.0, 0.0));\n"
	"}\n"
,
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm;   // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec3 viewNormal;\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"uniform float dist;\n"
	"uniform vec3 skycol;\n"
	"void main()\n"
	"{\n"
	"	float dist2 = dist*0.1;\n"
	"	float Fex = exp(-dist2*0.1);\n"
	"	float Fin = 1.0 - exp(-dist2*0.01);\n"
	"	vec3 col = vec3(1.0, 1.0,1.0)*Fex + Fin*skycol;\n"
	"	gl_FragData[0] = vec4(col, 1.0);\n"
	"	gl_FragData[1] = vec4(0.0);\n"
	"	gl_FragData[2] = vec4(0.0);\n"
	"}\n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec3 viewNormal;\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"void main()\n"
	"{\n"
	"	objectPos = pos;\n"
	"	worldPos = mm * pos;\n"
	"	viewPos = mvm * pos;\n"
	"	\n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	gl_Position = mvpm * pos;\n"
	"	//gl_Position = pm * (pos + vec4(0.0, 0.0, -10.0, 0.0));\n"
	"}\n"
,
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm;   // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec3 viewNormal;\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"uniform float dist;\n"
	"uniform vec3 skycol;\n"
	"void main()\n"
	"{\n"
	"	float dist2 = dist*0.1;\n"
	"	float Fex = exp(-dist2*0.1);\n"
	"	float Fin = 1.0 - exp(-dist2*0.01);\n"
	"	vec3 col = vec3(1.0, 1.0,1.0)*Fex + Fin*skycol;\n"
	"	gl_FragData[0] = vec4(col, 1.0);\n"
	"	gl_FragData[1] = viewPos;\n"
	"	gl_FragData[2] = vec4(normalize(viewNormal), 1.0);\n"
	"}\n"
,
	"#version 330 \n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec2 pos;\n"
	"out float intensity;\n"
	"layout(points) in;\n"
	"layout(triangle_strip, max_vertices = 4) out;\n"
	"uniform float time;\n"
	"float rand(vec2 co)\n"
	"{\n"
	"	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
	"}\n"
	"float randGaussian(vec2 co)\n"
	"{\n"
	"	float r1 = rand(co + vec2(71.3, 56.4));\n"
	"	float r2 = rand(co + vec2(32.9, 28.5));\n"
	"	return 0.03 + sqrt(-2.0*log(r1*0.999+0.001))*cos(6.283185*r2);\n"
	"}\n"
	"vec3 gauss3(vec2 p, float seed)\n"
	"{\n"
	"	return vec3(randGaussian(p + vec2(19.412 + seed*0.981, 11.183+seed*1.5677)), randGaussian(p + vec2(86.287+seed*4.6671, 87.242+seed*8.6112)), randGaussian(p + vec2(37.563+seed*3.367, 23.543+seed*5.729)));\n"
	"}\n"
	"void main()\n"
	"{	\n"
	"	vec4 wsPos = gl_in[0].gl_Position; \n"
	"	wsPos.xyz *= 100.0;\n"
	"	//wsPos.z *= 0.0;\n"
	"	//wsPos.z -= 50.0 + sin(time)*10.0*0.0;\n"
	"	vec3 n = gauss3(gl_in[0].gl_Position.xy, gl_in[0].gl_Position.z*19.0);\n"
	"	float scale = 0.3;\n"
	"	float freq = 0.7;\n"
	"	wsPos.x += cos(n.x * time * freq) * n.y * scale;\n"
	"	wsPos.y += cos(n.y * time * freq) * n.z * scale;\n"
	"	wsPos.z += cos(n.z * time * freq) * n.x * scale;\n"
	"	float size = 0.6;\n"
	"	// position particles (mod) around camera pos in world space\n"
	"	float modSize = 30.0;\n"
	"	vec3 wsCamPos = -transpose(mat3(vm)) * vm[3].xyz; // position of camera in world space (invert)\n"
	"	vec3 d = wsPos.xyz - wsCamPos; // position from cam pos\n"
	"	d = mod(d + modSize*0.5, modSize)-modSize*0.5; // modulate from camera pos\n"
	"	d += wsCamPos; // center at camera pos\n"
	"	// switch to view space\n"
	"	vec4 vsPos = vm * vec4(d, 1.0);	\n"
	"	vec3 camDir = normalize(vec3(0.0, sin(time)*500.0*0.0, 0.0)-vsPos.xyz);\n"
	"	vec3 pseudoUp = vec3(0.0, 1.0, 0.0);\n"
	"	//vec3 right_ = normalize(cross(pseudoUp, camDir));\n"
	"	//vec3 up_ = normalize(cross(camDir, right_));\n"
	"	vec3 pseudoRight = vec3(1.0, 0.0, 0.0);\n"
	"	vec3 up_ = normalize(cross(camDir, pseudoRight));\n"
	"	vec3 right_ = normalize(cross(camDir, up_));\n"
	"	vec4 up = vec4(up_*size, 0.0);\n"
	"	vec4 right = vec4(right_*size, 0.0);\n"
	"	//vec4 up = vec4(vec3(0.0, 1.0, 0.0)*size, 0.0);\n"
	"	//vec4 right = vec4(vec3(1.0, 0.0, 0.0)*size, 0.0);\n"
	"	gl_Position = pm*(vsPos + right - up);\n"
	"	pos = vec2(1.0, -1.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = pm*(vsPos + right + up);\n"
	"	pos = vec2(1.0, 1.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = pm*(vsPos - right - up);\n"
	"	pos = vec2(-1.0, -1.0);\n"
	"	EmitVertex();\n"
	"	gl_Position = pm*(vsPos - right + up);\n"
	"	pos = vec2(-1.0, 1.0);\n"
	"	EmitVertex();\n"
	"	EndPrimitive();\n"
	"	/*vec3 o = vec3(1.0, 0.0, -1.0)*0.07;\n"
	"	vec4 p = gl_in[0].gl_Position;\n"
	"	//float i = p.y;\n"
	"	//p.y = 0.0;\n"
	"	//float normindex = i / 3000.0;\n"
	"	//float size = 0.1 + 1.4/(0.1 + normindex*0.9);\n"
	"	//size = size* 1.4;\n"
	"	//float speed = 5.0/(size + 1.0);\n"
	"	//intensity = 0.1*size;\n"
	"	//float normpos = mod(normindex + time*1.0*speed, 1.0);\n"
	"	//intensity *= smoothstep(normpos, 0.0, 0.1) * (1.0 - normpos);\n"
	"	//p.y = normpos*normpos*4.0;//*sin(normpos+normindex);\n"
	"	//float scale = 2.0 * (1.0-normpos*0.6)*(1.0-normpos*0.6);\n"
	"	//p.x *= scale;\n"
	"	//p.z *= scale;\n"
	"	//p.x += sin(normpos*10.0 + normindex*20.0 + time*3.0)*0.5*normpos;\n"
	"	//p.z += sin(normpos*13.0 + normindex*17.0 + time*4.9)*0.5*normpos;\n"
	"	float size = 3.2;\n"
	"	p.y += 1.0;\n"
	"	//p *= 0.1;\n"
	"	//p.z -= 40.0;\n"
	"	o *= size;\n"
	"	mat4 m = mvpm;\n"
	"	if (size > 0.0)\n"
	"	{\n"
	"		gl_Position = m*(p + o.xzyy);\n"
	"		pos = vec2(1.0, -1.0);\n"
	"		EmitVertex();\n"
	"		gl_Position = m*(p + o.xxyy);\n"
	"		pos = vec2(1.0, 1.0);\n"
	"		EmitVertex();\n"
	"		gl_Position = m*(p + o.zzyy);\n"
	"		pos = vec2(-1.0, -1.0);\n"
	"		EmitVertex();\n"
	"		gl_Position = m*(p + o.zxyy);\n"
	"		pos = vec2(-1.0, 1.0);\n"
	"		EmitVertex();\n"
	"	}\n"
	"	*/\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"//in float intensity;\n"
	"void main()\n"
	"{\n"
	"	float d = length(pos);\n"
	"	float e = exp(-d*6.0)*0.06;// * intensity;\n"
	"	gl_FragData[0] = vec4(e, e, e, 1.0);\n"
	"	//gl_FragData[0] = vec4(0.2, 0.2, 0.2, 1.0);\n"
	"	//gl_FragData[1] = vec4(0.0);\n"
	"	//gl_FragData[2] = vec4(0.0);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform float iGlobalTime;\n"
	"// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n"
	"float field(in vec3 p) {\n"
	"	float strength = 7. + .03 * log(1.e-6 + fract(sin(iGlobalTime) * 4373.11));\n"
	"	float accum = 0.;\n"
	"	float prev = 0.;\n"
	"	float tw = 0.;\n"
	"	for (int i = 0; i < 32; ++i) {\n"
	"		float mag = dot(p, p);\n"
	"		p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n"
	"		float w = exp(-float(i) / 7.);\n"
	"		accum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n"
	"		tw += w;\n"
	"		prev = mag;\n"
	"	}\n"
	"	return max(0., 5. * accum / tw - .7);\n"
	"}\n"
	"void main() {\n"
	"	//vec2 uv = 2. * gl_FragCoord.xy / iResolution.xy - 1.;\n"
	"	//vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n"
	"	vec2 uv = 2 * pos - 1;\n"
	"	vec2 uvs = uv;\n"
	"	vec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n"
	"	p += .2 * vec3(sin(iGlobalTime / 16.), sin(iGlobalTime / 12.),  sin(iGlobalTime / 128.));\n"
	"	float t = field(p);\n"
	"	float v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n"
	"	gl_FragColor = mix(.4, 1., v) * vec4(1.8 * t * t * t, 1.4 * t * t, t, 1.0);\n"
	"} \n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"out vec3 viewNormal;\n"
	"void main()\n"
	"{\n"
	"	objectPos = pos;\n"
	"	worldPos = mm * pos;\n"
	"	viewPos = mvm * pos;\n"
	"	\n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	gl_Position = mvpm * pos;\n"
	"}\n"
,
	"#version 330\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"in vec3 viewNormal;\n"
	"void main()\n"
	"{\n"
	"	gl_FragColor = vec4(1.0, 0.5, 0.5, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"out vec3 viewNormal;\n"
	"void main()\n"
	"{\n"
	"	mat4 vm_notranslation = vm;\n"
	"	vm_notranslation[3] = vec4(0.0, 0.0, 0.0, 1.0);\n"
	"	//vm_notranslation[3][3] = 1.0;\n"
	"	objectPos = pos;\n"
	"	worldPos = mm * pos;\n"
	"	viewPos = vm_notranslation * mm * pos;\n"
	"	\n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	gl_Position = pm * vm_notranslation * mm * pos;\n"
	"}\n"
,
	"#version 330\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"in vec3 viewNormal;\n"
	"uniform samplerCube tex;\n"
	"void main()\n"
	"{\n"
	"	vec4 c = texture(tex, objectPos.xyz);\n"
	"	gl_FragColor = vec4(c.xyz, 1.0);\n"
	"	//gl_FragColor = vec4(0.5, 1.0, 0.0, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"in vec3 viewNormal;\n"
	"//\n"
	"// Description : Array and textureless GLSL 2D/3D/4D simplex \n"
	"//               noise functions.\n"
	"//      Author : Ian McEwan, Ashima Arts.\n"
	"//  Maintainer : ijm\n"
	"//     Lastmod : 20110822 (ijm)\n"
	"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n"
	"//               Distributed under the MIT License. See LICENSE file.\n"
	"//               https://github.com/ashima/webgl-noise\n"
	"// \n"
	"vec3 mod289(vec3 x) {\n"
	"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
	"}\n"
	"vec4 mod289(vec4 x) {\n"
	"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
	"}\n"
	"vec4 permute(vec4 x) {\n"
	"     return mod289(((x*34.0)+1.0)*x);\n"
	"}\n"
	"vec4 taylorInvSqrt(vec4 r)\n"
	"{\n"
	"  return 1.79284291400159 - 0.85373472095314 * r;\n"
	"}\n"
	"float snoise(vec3 v)\n"
	"  { \n"
	"  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n"
	"  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n"
	"// First corner\n"
	"  vec3 i  = floor(v + dot(v, C.yyy) );\n"
	"  vec3 x0 =   v - i + dot(i, C.xxx) ;\n"
	"// Other corners\n"
	"  vec3 g = step(x0.yzx, x0.xyz);\n"
	"  vec3 l = 1.0 - g;\n"
	"  vec3 i1 = min( g.xyz, l.zxy );\n"
	"  vec3 i2 = max( g.xyz, l.zxy );\n"
	"  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n"
	"  //   x1 = x0 - i1  + 1.0 * C.xxx;\n"
	"  //   x2 = x0 - i2  + 2.0 * C.xxx;\n"
	"  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n"
	"  vec3 x1 = x0 - i1 + C.xxx;\n"
	"  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n"
	"  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n"
	"// Permutations\n"
	"  i = mod289(i); \n"
	"  vec4 p = permute( permute( permute( \n"
	"             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n"
	"           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n"
	"           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n"
	"// Gradients: 7x7 points over a square, mapped onto an octahedron.\n"
	"// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n"
	"  float n_ = 0.142857142857; // 1.0/7.0\n"
	"  vec3  ns = n_ * D.wyz - D.xzx;\n"
	"  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n"
	"  vec4 x_ = floor(j * ns.z);\n"
	"  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n"
	"  vec4 x = x_ *ns.x + ns.yyyy;\n"
	"  vec4 y = y_ *ns.x + ns.yyyy;\n"
	"  vec4 h = 1.0 - abs(x) - abs(y);\n"
	"  vec4 b0 = vec4( x.xy, y.xy );\n"
	"  vec4 b1 = vec4( x.zw, y.zw );\n"
	"  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n"
	"  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n"
	"  vec4 s0 = floor(b0)*2.0 + 1.0;\n"
	"  vec4 s1 = floor(b1)*2.0 + 1.0;\n"
	"  vec4 sh = -step(h, vec4(0.0));\n"
	"  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n"
	"  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n"
	"  vec3 p0 = vec3(a0.xy,h.x);\n"
	"  vec3 p1 = vec3(a0.zw,h.y);\n"
	"  vec3 p2 = vec3(a1.xy,h.z);\n"
	"  vec3 p3 = vec3(a1.zw,h.w);\n"
	"//Normalise gradients\n"
	"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
	"  p0 *= norm.x;\n"
	"  p1 *= norm.y;\n"
	"  p2 *= norm.z;\n"
	"  p3 *= norm.w;\n"
	"// Mix final noise value\n"
	"  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n"
	"  m = m * m;\n"
	"  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n"
	"                                dot(p2,x2), dot(p3,x3) ) );\n"
	"}\n"
	"float rand(vec2 co)\n"
	"{\n"
	"	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
	"}\n"
	"float randGaussian(vec2 co)\n"
	"{\n"
	"	float r1 = rand(co + vec2(71.3, 56.4));\n"
	"	float r2 = rand(co + vec2(32.9, 28.5));\n"
	"	return 0.03 + sqrt(-2.0*log(r1*0.999+0.001))*cos(6.283185*r2);\n"
	"}\n"
	"vec3 gauss3(vec2 p, float seed)\n"
	"{\n"
	"	return vec3(randGaussian(p + vec2(19.412 + seed*0.981, 11.183+seed*1.5677)), randGaussian(p + vec2(86.287+seed*4.6671, 87.242+seed*8.6112)), randGaussian(p + vec2(37.563+seed*3.367, 23.543+seed*5.729)));\n"
	"}\n"
	"vec3 snoise(vec3 p, float d)\n"
	"{\n"
	"	return vec3(snoise(p - d), snoise(p), snoise(p + d));\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	//gl_FragColor = vec4(objectPos.xyz*0.5 + 0.5, 1.0);\n"
	"	vec3 pc = objectPos.xyz;\n"
	"	vec3 ps = normalize(objectPos.xyz);\n"
	"	// low freq noise\n"
	"	float lfd = 0.09;\n"
	"	float lffreq = 5.0;\n"
	"	float lfoffset = 0.0;\n"
	"	float lfmul = 2.0;\n"
	"	vec3 lfnoise = vec3(0.5);\n"
	"	for (int i=0; i<3; i++)\n"
	"	{\n"
	"		lfnoise += lfmul*snoise(ps*lffreq + lfoffset, lfd);\n"
	"		lfoffset += 3.0; lffreq *= 0.49; lfmul *= 0.8; \n"
	"	}\n"
	"	// high freq noise\n"
	"	float hfnoise = 1.0 - 0.2*snoise(ps*200.0 + 10.0);\n"
	"	// lights\n"
	"	vec3 v = vec3(0.0, 0.0, 0.0), po;\n"
	"	float d = 0.15*0.5*0.5*1.5;\n"
	"	float lpow = 400.0;\n"
	"	float lfreq = 1.8;\n"
	"	float lmul = 0.2;\n"
	"	for (int i=0; i<19; i++)\n"
	"	{\n"
	"		vec3 lp = normalize(vec3(0.0, 1.0, 0.0) + gauss3(vec2(9.8*i, 2.8*i), i*9.9));\n"
	"		po = normalize(ps + snoise(ps*lfreq - d + i*3.3)*lmul);\n"
	"		if (dot(lp, po)>0.0)\n"
	"			v.x += pow(dot(lp, po), lpow);\n"
	"		po = normalize(ps + snoise(ps*lfreq     + i*3.3)*lmul);\n"
	"		if (dot(lp, po)>0.0)\n"
	"			v.y += pow(dot(lp, po), lpow);\n"
	"		po = normalize(ps + snoise(ps*lfreq + d + i*3.3)*lmul);\n"
	"		if (dot(lp, po)>0.0)\n"
	"			v.z += pow(dot(lp, po), lpow);\n"
	"	}\n"
	"	//v = vec3(0.001);\n"
	"	//vec3 lp = normalize(vec3(0.0, 1.0, 0.0) + gauss3(vec2(9.8, 2.8), 9.9));\n"
	"	//po = normalize(ps + snoise(ps*lfreq - d + 3.3)*lmul);\n"
	"	//v.x += pow(abs(dot(lp, po)), 400.0);\n"
	"	\n"
	"	gl_FragColor = vec4(0.02 + lfnoise*hfnoise*vec3(0.5, 1.0, 0.6)*0.13*0.2 + v*100.0*hfnoise*vec3(0.5, 1.0, 0.6), 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"uniform sampler2D tex;\n"
	"uniform sampler2D texOld;\n"
	"uniform vec2 texSize;\n"
	"uniform float timeFrac;\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"out vec3 viewNormal;\n"
	"vec3 makenormal(vec3 center, vec3 p1, vec3 p2)\n"
	"{\n"
	"	return cross(p1-center, p2-center);\n"
	"}\n"
	"void computePosAndNormal(sampler2D posTex, vec2 pos, vec4 d, vec2 pxSize, out vec3 center, out vec3 n)\n"
	"{\n"
	"	// pos is used to index texture\n"
	"	center = texture2D(posTex, pos.xy).xyz;\n"
	"	n = vec3(0.0);\n"
	"	// right/left\n"
	"	vec3 sibling = texture2D(posTex, pos.xy + d.xw).xyz; // other point at same y\n"
	"	if ((pos.y - pxSize.y) > 0.0)\n"
	"	{\n"
	"		vec3 p1 = texture2D(posTex, pos.xy + d.wz).xyz; // down\n"
	"		vec3 p2 = texture2D(posTex, pos.xy + d.xz).xyz; // down right/left\n"
	"		n += makenormal(center.xyz, p1, p2);\n"
	"		n += makenormal(center.xyz, p2, sibling);\n"
	"	}\n"
	"	if ((pos.y + pxSize.y) < 1.0)\n"
	"	{\n"
	"		vec3 p1 = texture2D(posTex, pos.xy + d.wy).xyz; // up\n"
	"		vec3 p2 = texture2D(posTex, pos.xy + d.xy).xyz; // up right/left\n"
	"		n += makenormal(center.xyz, sibling, p2);\n"
	"		n += makenormal(center.xyz, p2, p1);\n"
	"	}\n"
	"	n = normalize(n);\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	// For texture lookup\n"
	"	vec2 pxSize = vec2(1.0) / texSize;\n"
	"	vec4 d = vec4(pxSize.x, pxSize.y, 0.0, 0.0);\n"
	"	d.x = -(mod(pos.x, 2.0*pxSize.x)-pxSize.x)*2.0;\n"
	"	d.z = -d.y;\n"
	"	d.w = 0.0; \n"
	"	vec3 newCenter, newNormal;\n"
	"	vec3 oldCenter, oldNormal;\n"
	"	computePosAndNormal(tex,    pos.xy/texSize, d, pxSize, newCenter, newNormal);\n"
	"	computePosAndNormal(texOld, pos.xy/texSize, d, pxSize, oldCenter, oldNormal);\n"
	"	vec3 center = mix(newCenter, oldCenter, 1.0-timeFrac);\n"
	"	vec3 normal = normalize(mix(newNormal, oldNormal, 1.0-timeFrac));\n"
	"	//vec4 p = pos + vec4(center.xyz*1.1, 0.0);\n"
	"	vec4 p = vec4(center, 1.0);\n"
	"	//p.xy *= 5.0;\n"
	"	objectPos = p;\n"
	"	worldPos = mm * p;\n"
	"	viewPos = mvm * p;\n"
	"	 \n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	if (viewNormal.z < 0)\n"
	"	{\n"
	"		viewNormal = -viewNormal;\n"
	"		objectNormal = -objectNormal;\n"
	"	}\n"
	"	gl_Position = mvpm * p;\n"
	"}\n"
,
	"#version 330\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"in vec3 viewNormal;\n"
	"uniform samplerCube envTex;\n"
	"void main()\n"
	"{\n"
	"	vec3 r = reflect(normalize(viewPos.xyz), viewNormal.xyz);\n"
	"	// transform back to world space for sampling\n"
	"	vec3 wsR = transpose(mat3(vm))*r; // transpose is inverse, as long as we don't care about translate (we don't in this case)\n"
	"	vec3 envc = texture(envTex, wsR).xyz;\n"
	"	float gray = dot(envc.rgb, vec3(0.299, 0.587, 0.114));\n"
	"	envc = mix(vec3(gray), envc, 0.6);\n"
	"	//envc = smoothstep(1.0, 2.0, envc);\n"
	"	envc = max(vec3(0.0), envc - 2.0);\n"
	"	//gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
	"	// tweak the green color here for interesting stuff\n"
	"	// tweak negative factor for darkening of strands\n"
	"	gl_FragColor = vec4(vec3(0.8, 5.2, 1.8)*0.015*-6.0 + envc.xyz, 1.0);\n"
	"	//gl_FragColor = vec4(viewNormal, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform vec2 viewportSize;\n"
	"uniform float time;\n"
	"uniform mat4 sphereTransform; \n"
	"float rand(vec2 co)\n"
	"{\n"
	"	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
	"}\n"
	"float randGaussian(vec2 co)\n"
	"{\n"
	"	float r1 = rand(co + vec2(71.3, 56.4));\n"
	"	float r2 = rand(co + vec2(32.9, 28.5));\n"
	"	return 0.03 + sqrt(-2.0*log(r1*0.999+0.001))*cos(6.283185*r2);\n"
	"}\n"
	"vec3 gauss3(vec2 p, float seed)\n"
	"{\n"
	"	return vec3(randGaussian(p + vec2(19.412 + seed*0.981, 11.183+seed*1.5677)), randGaussian(p + vec2(86.287+seed*4.6671, 87.242+seed*8.6112)), randGaussian(p + vec2(37.563+seed*3.367, 23.543+seed*5.729)));\n"
	"}\n"
	"const float minR = 2.0;\n"
	"const float maxR = 5.0;\n"
	"const float deltaR = maxR - minR;\n"
	"void main()\n"
	"{\n"
	"	float u = floor(pos.x*viewportSize.x);\n"
	"	float v = floor(pos.y*viewportSize.y);\n"
	"	float n = floor(u*0.5); // ribbon number\n"
	"	float i = floor((u-n*2.0)+0.5); // 0 or 1 for left or right\n"
	"	vec3 dir = normalize(gauss3(vec2(n), 23.151));\n"
	"	vec3 tangent = cross(dir, normalize(gauss3(vec2(n), 16.234)));\n"
	"	vec4 p = sphereTransform*vec4(vec3(dir*(minR + deltaR*pos.y)+tangent*0.2*i), 1.0);\n"
	"	gl_FragColor = vec4(p.xyz, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"uniform vec2 viewportSize;\n"
	"uniform vec2 pxSize;\n"
	"in vec2 pos;\n"
	"uniform sampler2D curPosTex;\n"
	"uniform sampler2D oldPosTex;\n"
	"uniform float deltaTime;\n"
	"uniform float prevDeltaTime;\n"
	"uniform mat4 sphereTransform; \n"
	"void main()\n"
	"{\n"
	"	float u = floor(pos.x*viewportSize.x);\n"
	"	float v = floor(pos.y*viewportSize.y);\n"
	"	float n = floor(u*0.5); // ribbon number\n"
	"	float i = floor((u-n*2.0)+0.5); // 0 or 1 for left or right\n"
	"	vec3 prev = texture2D(oldPosTex, pos).xyz;\n"
	"	vec3 cur = texture2D(curPosTex, pos).xyz;\n"
	"	vec3 new;\n"
	"	vec3 a = vec3(0.0, -3.5, 0.0);\n"
	"	vec3 vel = cur-prev;\n"
	"	new = cur + vel*0.997 + a*deltaTime*deltaTime;\n"
	"	gl_FragData[0] = vec4(new, 1.0);\n"
	"}\n"
,
	"uniform sampler2D input0;\n"
	"uniform vec2 pxSize;\n"
	"uniform vec2 viewportSize;\n"
	"in vec2 pos;\n"
	"const vec3 vSphereCenter = vec3(0.0);\n"
	"const float minR = 2.0;\n"
	"const float maxR = 5.0;\n"
	"const float deltaR = maxR - minR;\n"
	"uniform mat4 sphereTransform; \n"
	"vec3 force(vec3 s, vec3 o, float desDist)\n"
	"{\n"
	"	vec3 delta = s - o;\n"
	"	float l = length(delta);\n"
	"	return normalize(delta)*(desDist-l);\n"
	"}\n"
	"float rand(vec2 co)\n"
	"{\n"
	"	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
	"}\n"
	"float randGaussian(vec2 co)\n"
	"{\n"
	"	float r1 = rand(co + vec2(71.3, 56.4));\n"
	"	float r2 = rand(co + vec2(32.9, 28.5));\n"
	"	return 0.03 + sqrt(-2.0*log(r1*0.999+0.001))*cos(6.283185*r2);\n"
	"}\n"
	"vec3 gauss3(vec2 p, float seed)\n"
	"{\n"
	"	return vec3(randGaussian(p + vec2(19.412 + seed*0.981, 11.183+seed*1.5677)), randGaussian(p + vec2(86.287+seed*4.6671, 87.242+seed*8.6112)), randGaussian(p + vec2(37.563+seed*3.367, 23.543+seed*5.729)));\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	vec4 d = vec4(pxSize.x, pxSize.y, 0.0, 0.0);\n"
	"	d.x = -(mod(pos.x, 2.0*pxSize.x)-pxSize.x)*2.0;\n"
	"	d.z = -d.y;\n"
	"	d.w = 0.0; \n"
	"	vec3 des = vec3(0.20, deltaR/64.0, 0.0);\n"
	"	des.z = length(des.xy);\n"
	"	vec3 f = vec3(0.0);\n"
	"	vec3 c = texture2D(input0, pos).xyz;\n"
	"	vec3 o;\n"
	"	float accWeight = 0.0;\n"
	"	if ((pos.y - pxSize.y) > 0.0)\n"
	"	{\n"
	"		// down\n"
	"		o = texture2D(input0, pos + d.wz).xyz;\n"
	"		f += 0.5*force(c, o, des.y);\n"
	"		// down right/left\n"
	"		o = texture2D(input0, pos + d.xz).xyz;\n"
	"		f += 0.5*force(c, o, des.z);\n"
	"		// right/left\n"
	"		o = texture2D(input0, pos + d.xw).xyz;\n"
	"		f += 0.5*force(c, o, des.x);\n"
	"		if ((pos.y + pxSize.y) < 1.0)\n"
	"		{\n"
	"			// up\n"
	"			o = texture2D(input0, pos + d.wy).xyz;\n"
	"			f += 0.5*force(c, o, des.y);\n"
	"	\n"
	"			// up right/left\n"
	"			o = texture2D(input0, pos + d.xy).xyz;\n"
	"	 		f += 0.5*force(c, o, des.z);\n"
	"			// center between up/down neighbours (straighten)\n"
	"			//o = 0.975*(texture2D(input0, pos + d.wz).xyz + texture2D(input0, pos + d.wy).xyz)*0.5;\n"
	"	 		//f += 0.01*force(c, o, 0.0);\n"
	"	 	}\n"
	"		// Sphere constraint\n"
	"		if (length(c) < 0.6)\n"
	"		{\n"
	"			o = vSphereCenter;\n"
	"			f += force(c, o, 0.7)*smoothstep(length(c - vSphereCenter), 0.7, 0.6);\n"
	"		}\n"
	"		gl_FragColor = vec4(c + f*0.6, 1.0);\n"
	"	}\n"
	"	else\n"
	"	{\n"
	"		float u = floor(pos.x*viewportSize.x);\n"
	"		float v = floor(pos.y*viewportSize.y);\n"
	"		float n = floor(u*0.5); // ribbon number\n"
	"		float i = floor((u-n*2.0)+0.5); // 0 or 1 for left or right\n"
	"		vec3 dir = normalize(gauss3(vec2(n), 23.151));\n"
	"		vec3 tangent = cross(dir, normalize(gauss3(vec2(n), 16.234)));\n"
	"		vec4 p = sphereTransform*vec4(vec3(dir*(minR + deltaR*pos.y)+tangent*0.2*i), 1.0);\n"
	"		gl_FragColor = vec4(p.xyz, 1.0);\n"
	"	}\n"
	"}\n"
,
	"#version 330\n"
	"layout(location = 0) in vec4 pos;\n"
	"layout(location = 1) in vec3 normal;\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm; // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"out vec3 viewNormal;\n"
	"out vec4 objectPos;\n"
	"out vec4 worldPos;\n"
	"out vec4 viewPos;\n"
	"out vec3 objectNormal;\n"
	"void main()\n"
	"{\n"
	"	mat4 view = vm;\n"
	"	view[3][0] = 0.0;\n"
	"	view[3][1] = 0.0;\n"
	"	view[3][2] = 0.0;\n"
	"	view = view;\n"
	"	objectPos = pos;\n"
	"	worldPos = mm * pos;\n"
	"	viewPos = view * mm * pos;\n"
	"	\n"
	"	objectNormal = normal;\n"
	"	viewNormal = normalize(nmvm * normal);\n"
	"	gl_Position = pm * view * mm * pos;\n"
	"	//gl_Position = pm * (pos + vec4(0.0, 0.0, -10.0, 0.0));\n"
	"}\n"
,
	"#version 330\n"
	"uniform mat4 pm;   // projection\n"
	"uniform mat4 vm;   // view\n"
	"uniform mat4 mm;   // model\n"
	"uniform mat3 nmvm;   // normal\n"
	"uniform mat4 mvm;  // modelview\n"
	"uniform mat4 mvpm; // modelviewprojection\n"
	"in vec3 viewNormal;\n"
	"in vec4 objectPos;\n"
	"in vec4 worldPos;\n"
	"in vec4 viewPos;\n"
	"in vec3 objectNormal;\n"
	"vec3 XYZtoRGB(vec3 XYZ)\n"
	"{\n"
	"	mat3 m = mat3(\n"
	"		3.240479, -1.53715, -0.49853,\n"
	"		-0.969256, 1.875991, 0.041556,\n"
	"		0.055648, -0.204043, 1.057311\n"
	"	);\n"
	"	return transpose(m)*XYZ;\n"
	"}\n"
	"vec3 YxytoXYZ(vec3 Yxy)\n"
	"{\n"
	"	float x = Yxy.x;\n"
	"	float y = Yxy.y;\n"
	"	float Y = Yxy.z;\n"
	"	\n"
	"	vec3 XYZ;\n"
	"	XYZ.x = x * (Y / y);\n"
	"	XYZ.y = Y;\n"
	"	XYZ.z = (1.0 - x - y) * (Y / y);\n"
	"	return XYZ;\n"
	"}\n"
	"mat4 Mx = mat4(\n"
	"	0.00166, -0.00375, 0.00209, 0.0,\n"
	"	-0.02903, 0.06377, -0.03203, 0.00394,\n"
	"	0.11693, -0.21196, 0.06052, 0.25886,\n"
	"	0.0, 0.0, 0.0, 0.0\n"
	");\n"
	"mat4 My = mat4(\n"
	"	0.00275, -0.00610, 0.00317, 0.0,\n"
	"	-0.04214, 0.08970, -0.04153, 0.00516,\n"
	"	0.15346, -0.26756, 0.06670, 0.26688,\n"
	"	0.0, 0.0, 0.0, 0.0\n"
	");\n"
	"float YDCa[5] = float[5](0.1787, -0.3554, -0.0227,  0.1206, -0.0670);\n"
	"float YDCb[5] = float[5](-1.4630, 0.4275, 5.3251, -2.5771, 0.3703);\n"
	"float xDCa[5] = float[5](-0.0193, -0.0665, -0.0004, -0.0641, -0.0033);\n"
	"float xDCb[5] = float[5](-0.2592, 0.0008, 0.2125, -0.8989, 0.0452);\n"
	"float yDCa[5] = float[5](-0.0167, -0.0950, -0.0079, -0.0441, -0.0109);\n"
	"float yDCb[5] = float[5](-0.2608, 0.0092, 0.2102, -1.6537, 0.0529);\n"
	"float perez(float A, float B, float C, float D, float E, float theta, float phi)\n"
	"{\n"
	"	return (1.0 + A * exp(B / cos(theta)))*(1.0 + C*exp(D*phi) + E * cos(phi) * cos(phi));\n"
	"}\n"
	"float distribution(float a[5], float b[5], float T, float theta, float gamma, float thetaSun)\n"
	"{\n"
	"	float A = a[0]*T + b[0];\n"
	"	float B = a[1]*T + b[1];\n"
	"	float C = a[2]*T + b[2];\n"
	"	float D = a[3]*T + b[3];\n"
	"	float E = a[4]*T + b[4];\n"
	"	return perez(A, B, C, D, E, theta, gamma) / perez(A, B, C, D, E, 0, thetaSun); \n"
	"}\n"
	"void main()\n"
	"{\n"
	"	gl_FragData[1] = vec4(0.0);\n"
	"	gl_FragData[2] = vec4(0.0);\n"
	"	vec3 sunDir = normalize(vec3(mm * vec4(10.0, 0.0, 0.0, 1.0)));\n"
	"	vec3 lookDir = normalize(worldPos.xyz);\n"
	"	float theta = acos(dot(lookDir, vec3(0.0, 1.0, 0.0)));\n"
	"	float thetaSun = acos(dot(sunDir, vec3(0.0, 1.0, 0.0)));\n"
	"	float gamma = acos(dot(sunDir, lookDir));\n"
	"	if (lookDir.y < 0.0)\n"
	"	{\n"
	"		gl_FragData[0] = vec4(0.0, 0.0, 0.0, 1.0);\n"
	"		return;\n"
	"	}\n"
	"	float T = 2.0;\n"
	"	vec4 thetaVec = vec4(thetaSun*thetaSun*thetaSun, thetaSun*thetaSun, thetaSun, 1);\n"
	"	vec4 Tvec = vec4(T*T, T, 1, 0.0);\n"
	"	\n"
	"	vec3 zenith;\n"
	"	zenith.x = dot(Tvec, transpose(Mx) * thetaVec);\n"
	"	zenith.y = dot(Tvec, transpose(My) * thetaVec);\n"
	"	zenith.z = (4.0453*T - 4.9710)*tan((4.0/9.0 - T/120.0)*(3.141592 - 2.0*thetaSun)) - 0.2155*T + 2.4192;\n"
	"	if (zenith.z < 0.0)\n"
	"		zenith.z = 0.0;\n"
	"	//zenith.z = 1.0 - exp(-zenith.z / 25.0);\n"
	"	zenith.z /= 10.0;\n"
	"	vec3 color;\n"
	"	color.x = zenith.x * distribution(xDCa, xDCb, T, theta, gamma, thetaSun);\n"
	"	color.y = zenith.y * distribution(yDCa, yDCb, T, theta, gamma, thetaSun);\n"
	"	color.z = zenith.z * distribution(YDCa, YDCb, T, theta, gamma, thetaSun);\n"
	"	vec3 sunCol;\n"
	"	float gammaF = 1.0;\n"
	"	float colF = 10000.0;\n"
	"	float sunGamma = max(gamma*4.0 - 0.1, 0.0);\n"
	"	sunCol.x = exp(-sunGamma*55.0*gammaF) * colF;\n"
	"	sunCol.y = exp(-sunGamma*85.0*gammaF) * colF;\n"
	"	sunCol.z = exp(-sunGamma*115.0*gammaF) * colF;\n"
	"	\n"
	"	vec3 colorXYZ = XYZtoRGB(YxytoXYZ(color));\n"
	"	vec4 outCol;\n"
	"	outCol.x = colorXYZ.x;\n"
	"	outCol.y = colorXYZ.y;\n"
	"	outCol.z = colorXYZ.z;\n"
	"	outCol.w = 1.0;\n"
	"	//colorXYZ *= vec3(1.2, 1.0/1.2, 1.0);\n"
	"	gl_FragData[0] = vec4(colorXYZ * vec3(1.0) + sunCol, 1.0);\n"
	"	//gl_FragData[0] = outCol;\n"
	"//	gl_FragData[0] = vec4(lookDir, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D tex;\n"
	"uniform float angle;\n"
	"uniform float amplitude;\n"
	"uniform float frequency;\n"
	"void main()\n"
	"{\n"
	"	float v = dot(vec2(cos(angle), sin(angle)), pos);\n"
	"	gl_FragColor = texture2D(tex, pos + vec2(sin(angle), -cos(angle))*amplitude*sin(v*frequency));\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D input0;\n"
	"uniform sampler2D input1;\n"
	"uniform int mode;\n"
	"void main()\n"
	"{\n"
	"	vec4 c0 = texture2D(input0, pos);\n"
	"	vec4 c1 = texture2D(input1, pos);\n"
	"	if (mode==1)\n"
	"		gl_FragData[0] = vec4(c0.rgb*pow(c1.rgb, vec3(2.5)), c0.a);\n"
	"	else if (mode==2)\n"
	"		//gl_FragData[0] = vec4(c0.rgb*(1.0 - c1.a) + c1.rgb*c1.a, 1.0);\n"
	"		gl_FragData[0] = vec4(c0.rgb*(1.0-c1.a) + c1.rgb*c1.a, 1.0);\n"
	"	else\n"
	"		gl_FragData[0] = vec4(0.0);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D tex;\n"
	"void main()\n"
	"{\n"
	"	float d = sqrt(dot(pos*2.0-1.0, pos*2.0-1.0));\n"
	"	float c = cos(d*0.6);\n"
	"	vec3 col = texture2D(tex, pos).xyz;\n"
	"	//c = 1.0;\n"
	"	gl_FragColor = vec4(col*c*c*c*c, 1.0);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D input0;\n"
	"uniform float exposure;\n"
	"uniform int mode;\n"
	"void main()\n"
	"{\n"
	"	if (mode==0)\n"
	"	{\n"
	"		vec3 texColorIn = texture2D(input0, pos).xyz;\n"
	"		vec3 texColorExp = texColorIn * exposure;  // Exposure adjustment\n"
	"		texColorExp = texColorExp/(1.0+texColorExp);\n"
	"		vec3 retColor = pow(texColorExp, vec3(1.0/2.2));\n"
	"		gl_FragData[0] = vec4(retColor, 1.0);\n"
	"	}\n"
	"	else if (mode==1)\n"
	"	{\n"
	"		vec3 texColorIn = texture2D(input0, pos).xyz;\n"
	"		vec3 texColorExp = texColorIn * exposure;  // Exposure adjustment\n"
	"		vec3 x = max(vec3(0.0), texColorExp-0.004);\n"
	"		vec3 retColor = (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\n"
	"		vec3 finalColor = retColor;\n"
	"		gl_FragData[0] = vec4(finalColor, 1.0);\n"
	"	}\n"
	"}\n"
,
	"uniform sampler2D input0;\n"
	"varying vec2 pos;\n"
	"uniform float fScale;\n"
	"uniform float fDamping;\n"
	"uniform float fAngle;\n"
	"uniform float fPass;\n"
	"uniform vec2 pxSize;\n"
	"vec4 zoomed(float scale)\n"
	"{\n"
	"	float angle = fAngle * 3.1415921 / 180.0;\n"
	"/*	vec2 d = pos - vec2(fCenterX, fCenterY);\n"
	"	mat2 r = mat2(cos(fAngle), sin(fAngle), -sin(fAngle), cos(fAngle));\n"
	"	d *= r;\n"
	"	d *= vec2(scaleX, scaleY);\n"
	"	d *= transpose(r);*/\n"
	"	vec2 d = pos + scale*vec2(cos(angle), sin(angle))*pxSize/pxSize.y;\n"
	"	return texture2D(input0, d);\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	\n"
	"//	float scale = pow(5.0, pow(4.0, fPass));\n"
	"//	float scale = fScale*pow(0.333333, fPass)*0.01;\n"
	"	float scale = fScale*pow(0.707, fPass);\n"
	"//	float scaleY = pow(fScaleY, pow(4.0, fPass));\n"
	"//	float damping = pow(fDamping, fPass);\n"
	"	float damping = fDamping;\n"
	"//	float scaleX = fScaleX;\n"
	"//	float scaleY = fScaleY;\n"
	"//	float damping = fDamping;\n"
	"/*	float scaleX2 = scaleX*scaleX;\n"
	"	float scaleY2 = scaleY*scaleY;*/\n"
	"	float damping2 = damping*damping;\n"
	"	float scale2 = scale*scale;\n"
	"	\n"
	"	float norm = (1.0) / (1.0 + 2.0 * damping + 2.0 * damping2);\n"
	"//	norm = 1.0;\n"
	"//damping = 1.0;\n"
	"//norm = 1.0 / 3.0;\n"
	"//	gl_FragColor = zoomed(scaleX, scaleY);\n"
	"	gl_FragData[0] =\n"
	"		+ (1.0                * norm) * zoomed(0.0)\n"
	"		+ (damping            * norm) * zoomed(scale)\n"
	"		+ (damping            * norm) * zoomed(-scale)\n"
	"		+ (damping2           * norm) * zoomed(scale*2.0)\n"
	"		+ (damping2           * norm) * zoomed(-scale*2.0);\n"
	"	//gl_FragData[0] = texture2D(input0, pos);\n"
	"		\n"
	"}\n"
,
	"uniform sampler2D input0;\n"
	"varying vec2 pos;\n"
	"uniform float fThresh;\n"
	"uniform float fSmooth;\n"
	"void main()\n"
	"{\n"
	"	vec3 d = vec3(0.3, 0.6, 0.1);\n"
	"	vec4 c = texture2D(input0, pos);\n"
	"	float l = dot(d, c.xyz);\n"
	"	c *= smoothstep(fThresh-fSmooth, fThresh+fSmooth, l);\n"
	"	gl_FragColor = c;\n"
	"}\n"
,
	"uniform sampler2D input0;\n"
	"uniform sampler2D input1;\n"
	"varying vec2 pos;\n"
	"uniform float fMul0;\n"
	"uniform float fMul1;\n"
	"void main()\n"
	"{\n"
	"	vec4 c0 = texture2D(input0, pos);\n"
	"	vec4 c1 = texture2D(input1, pos);\n"
	"	gl_FragData[0] = (c0*fMul0) + (c1*fMul1);\n"
	"	gl_FragData[0].a = 1.0;\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D tex;\n"
	"void main()\n"
	"{\n"
	"	vec3 luma = vec3(0.299, 0.587, 0.114);\n"
	"	vec4 c = texture2D(tex, pos);\n"
	"	c.a = dot(luma, c.rgb);\n"
	"	gl_FragColor = c;\n"
	"}\n"
,
	"#version 130\n"
	"#define FXAA_PC 1\n"
	"#define FXAA_GLSL_130 1\n"
	"#define FXAA_DISCARD 1\n"
	"//#define FXAA_QUALITY__PRESET 29\n"
	"#define FXAA_QUALITY__PRESET 39\n"
	"#extension GL_ARB_gpu_shader5 : enable\n"
	"// look at bottom for main\n"
	"/*============================================================================\n"
	"                             INTEGRATION KNOBS\n"
	"============================================================================*/\n"
	"//\n"
	"// FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).\n"
	"// FXAA_360_OPT is a prototype for the new optimized 360 version.\n"
	"//\n"
	"// 1 = Use API.\n"
	"// 0 = Don't use API.\n"
	"//\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_PS3\n"
	"    #define FXAA_PS3 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_360\n"
	"    #define FXAA_360 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_360_OPT\n"
	"    #define FXAA_360_OPT 0\n"
	"#endif\n"
	"/*==========================================================================*/\n"
	"#ifndef FXAA_PC\n"
	"    //\n"
	"    // FXAA Quality\n"
	"    // The high quality PC algorithm.\n"
	"    //\n"
	"    #define FXAA_PC 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_PC_CONSOLE\n"
	"    //\n"
	"    // The console algorithm for PC is included\n"
	"    // for developers targeting really low spec machines.\n"
	"    // Likely better to just run FXAA_PC, and use a really low preset.\n"
	"    //\n"
	"    #define FXAA_PC_CONSOLE 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_GLSL_120\n"
	"    #define FXAA_GLSL_120 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_GLSL_130\n"
	"    #define FXAA_GLSL_130 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_HLSL_3\n"
	"    #define FXAA_HLSL_3 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_HLSL_4\n"
	"    #define FXAA_HLSL_4 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_HLSL_5\n"
	"    #define FXAA_HLSL_5 0\n"
	"#endif\n"
	"/*==========================================================================*/\n"
	"#ifndef FXAA_GREEN_AS_LUMA\n"
	"    //\n"
	"    // For those using non-linear color,\n"
	"    // and either not able to get luma in alpha, or not wanting to,\n"
	"    // this enables FXAA to run using green as a proxy for luma.\n"
	"    // So with this enabled, no need to pack luma in alpha.\n"
	"    //\n"
	"    // This will turn off AA on anything which lacks some amount of green.\n"
	"    // Pure red and blue or combination of only R and B, will get no AA.\n"
	"    //\n"
	"    // Might want to lower the settings for both,\n"
	"    //    fxaaConsoleEdgeThresholdMin\n"
	"    //    fxaaQualityEdgeThresholdMin\n"
	"    // In order to insure AA does not get turned off on colors \n"
	"    // which contain a minor amount of green.\n"
	"    //\n"
	"    // 1 = On.\n"
	"    // 0 = Off.\n"
	"    //\n"
	"    #define FXAA_GREEN_AS_LUMA 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_EARLY_EXIT\n"
	"    //\n"
	"    // Controls algorithm's early exit path.\n"
	"    // On PS3 turning this ON adds 2 cycles to the shader.\n"
	"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n"
	"    // Turning this off on console will result in a more blurry image.\n"
	"    // So this defaults to on.\n"
	"    //\n"
	"    // 1 = On.\n"
	"    // 0 = Off.\n"
	"    //\n"
	"    #define FXAA_EARLY_EXIT 1\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_DISCARD\n"
	"    //\n"
	"    // Only valid for PC OpenGL currently.\n"
	"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n"
	"    //\n"
	"    // 1 = Use discard on pixels which don't need AA.\n"
	"    //     For APIs which enable concurrent TEX+ROP from same surface.\n"
	"    // 0 = Return unchanged color on pixels which don't need AA.\n"
	"    //\n"
	"    #define FXAA_DISCARD 0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_FAST_PIXEL_OFFSET\n"
	"    //\n"
	"    // Used for GLSL 120 only.\n"
	"    //\n"
	"    // 1 = GL API supports fast pixel offsets\n"
	"    // 0 = do not use fast pixel offsets\n"
	"    //\n"
	"    #ifdef GL_EXT_gpu_shader4\n"
	"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
	"    #endif\n"
	"    #ifdef GL_NV_gpu_shader5\n"
	"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
	"    #endif\n"
	"    #ifdef GL_ARB_gpu_shader5\n"
	"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
	"    #endif\n"
	"    #ifndef FXAA_FAST_PIXEL_OFFSET\n"
	"        #define FXAA_FAST_PIXEL_OFFSET 0\n"
	"    #endif\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_GATHER4_ALPHA\n"
	"    //\n"
	"    // 1 = API supports gather4 on alpha channel.\n"
	"    // 0 = API does not support gather4 on alpha channel.\n"
	"    //\n"
	"    #if (FXAA_HLSL_5 == 1)\n"
	"        #define FXAA_GATHER4_ALPHA 1\n"
	"    #endif\n"
	"    #ifdef GL_ARB_gpu_shader5\n"
	"        #define FXAA_GATHER4_ALPHA 1\n"
	"    #endif\n"
	"    #ifdef GL_NV_gpu_shader5\n"
	"        #define FXAA_GATHER4_ALPHA 1\n"
	"    #endif\n"
	"    #ifndef FXAA_GATHER4_ALPHA\n"
	"        #define FXAA_GATHER4_ALPHA 0\n"
	"    #endif\n"
	"#endif\n"
	"/*============================================================================\n"
	"                      FXAA CONSOLE PS3 - TUNING KNOBS\n"
	"============================================================================*/\n"
	"#ifndef FXAA_CONSOLE__PS3_EDGE_SHARPNESS\n"
	"    //\n"
	"    // Consoles the sharpness of edges on PS3 only.\n"
	"    // Non-PS3 tuning is done with shader input.\n"
	"    //\n"
	"    // Due to the PS3 being ALU bound,\n"
	"    // there are only two safe values here: 4 and 8.\n"
	"    // These options use the shaders ability to a free *|/ by 2|4|8.\n"
	"    //\n"
	"    // 8.0 is sharper\n"
	"    // 4.0 is softer\n"
	"    // 2.0 is really soft (good for vector graphics inputs)\n"
	"    //\n"
	"    #if 1\n"
	"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 8.0\n"
	"    #endif\n"
	"    #if 0\n"
	"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 4.0\n"
	"    #endif\n"
	"    #if 0\n"
	"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 2.0\n"
	"    #endif\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#ifndef FXAA_CONSOLE__PS3_EDGE_THRESHOLD\n"
	"    //\n"
	"    // Only effects PS3.\n"
	"    // Non-PS3 tuning is done with shader input.\n"
	"    //\n"
	"    // The minimum amount of local contrast required to apply algorithm.\n"
	"    // The console setting has a different mapping than the quality setting.\n"
	"    //\n"
	"    // This only applies when FXAA_EARLY_EXIT is 1.\n"
	"    //\n"
	"    // Due to the PS3 being ALU bound,\n"
	"    // there are only two safe values here: 0.25 and 0.125.\n"
	"    // These options use the shaders ability to a free *|/ by 2|4|8.\n"
	"    //\n"
	"    // 0.125 leaves less aliasing, but is softer\n"
	"    // 0.25 leaves more aliasing, and is sharper\n"
	"    //\n"
	"    #if 1\n"
	"        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.125\n"
	"    #else\n"
	"        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.25\n"
	"    #endif\n"
	"#endif\n"
	"/*============================================================================\n"
	"                        FXAA QUALITY - TUNING KNOBS\n"
	"------------------------------------------------------------------------------\n"
	"NOTE the other tuning knobs are now in the shader function inputs!\n"
	"============================================================================*/\n"
	"#ifndef FXAA_QUALITY__PRESET\n"
	"    //\n"
	"    // Choose the quality preset.\n"
	"    // This needs to be compiled into the shader as it effects code.\n"
	"    // Best option to include multiple presets is to \n"
	"    // in each shader define the preset, then include this file.\n"
	"    // \n"
	"    // OPTIONS\n"
	"    // -----------------------------------------------------------------------\n"
	"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n"
	"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n"
	"    // 39       - no dither, very expensive \n"
	"    //\n"
	"    // NOTES\n"
	"    // -----------------------------------------------------------------------\n"
	"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n"
	"    // 13 = about same speed as FXAA 3.9 and better than 12\n"
	"    // 23 = closest to FXAA 3.9 visually and performance wise\n"
	"    //  _ = the lowest digit is directly related to performance\n"
	"    // _  = the highest digit is directly related to style\n"
	"    // \n"
	"    #define FXAA_QUALITY__PRESET 12\n"
	"#endif\n"
	"/*============================================================================\n"
	"                           FXAA QUALITY - PRESETS\n"
	"============================================================================*/\n"
	"/*============================================================================\n"
	"                     FXAA QUALITY - MEDIUM DITHER PRESETS\n"
	"============================================================================*/\n"
	"#if (FXAA_QUALITY__PRESET == 10)\n"
	"    #define FXAA_QUALITY__PS 3\n"
	"    #define FXAA_QUALITY__P0 1.5\n"
	"    #define FXAA_QUALITY__P1 3.0\n"
	"    #define FXAA_QUALITY__P2 12.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 11)\n"
	"    #define FXAA_QUALITY__PS 4\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 3.0\n"
	"    #define FXAA_QUALITY__P3 12.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 12)\n"
	"    #define FXAA_QUALITY__PS 5\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 4.0\n"
	"    #define FXAA_QUALITY__P4 12.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 13)\n"
	"    #define FXAA_QUALITY__PS 6\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 4.0\n"
	"    #define FXAA_QUALITY__P5 12.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 14)\n"
	"    #define FXAA_QUALITY__PS 7\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 4.0\n"
	"    #define FXAA_QUALITY__P6 12.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 15)\n"
	"    #define FXAA_QUALITY__PS 8\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 4.0\n"
	"    #define FXAA_QUALITY__P7 12.0\n"
	"#endif\n"
	"/*============================================================================\n"
	"                     FXAA QUALITY - LOW DITHER PRESETS\n"
	"============================================================================*/\n"
	"#if (FXAA_QUALITY__PRESET == 20)\n"
	"    #define FXAA_QUALITY__PS 3\n"
	"    #define FXAA_QUALITY__P0 1.5\n"
	"    #define FXAA_QUALITY__P1 2.0\n"
	"    #define FXAA_QUALITY__P2 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 21)\n"
	"    #define FXAA_QUALITY__PS 4\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 22)\n"
	"    #define FXAA_QUALITY__PS 5\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 23)\n"
	"    #define FXAA_QUALITY__PS 6\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 24)\n"
	"    #define FXAA_QUALITY__PS 7\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 3.0\n"
	"    #define FXAA_QUALITY__P6 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 25)\n"
	"    #define FXAA_QUALITY__PS 8\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 4.0\n"
	"    #define FXAA_QUALITY__P7 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 26)\n"
	"    #define FXAA_QUALITY__PS 9\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 2.0\n"
	"    #define FXAA_QUALITY__P7 4.0\n"
	"    #define FXAA_QUALITY__P8 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 27)\n"
	"    #define FXAA_QUALITY__PS 10\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 2.0\n"
	"    #define FXAA_QUALITY__P7 2.0\n"
	"    #define FXAA_QUALITY__P8 4.0\n"
	"    #define FXAA_QUALITY__P9 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 28)\n"
	"    #define FXAA_QUALITY__PS 11\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 2.0\n"
	"    #define FXAA_QUALITY__P7 2.0\n"
	"    #define FXAA_QUALITY__P8 2.0\n"
	"    #define FXAA_QUALITY__P9 4.0\n"
	"    #define FXAA_QUALITY__P10 8.0\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_QUALITY__PRESET == 29)\n"
	"    #define FXAA_QUALITY__PS 12\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.5\n"
	"    #define FXAA_QUALITY__P2 2.0\n"
	"    #define FXAA_QUALITY__P3 2.0\n"
	"    #define FXAA_QUALITY__P4 2.0\n"
	"    #define FXAA_QUALITY__P5 2.0\n"
	"    #define FXAA_QUALITY__P6 2.0\n"
	"    #define FXAA_QUALITY__P7 2.0\n"
	"    #define FXAA_QUALITY__P8 2.0\n"
	"    #define FXAA_QUALITY__P9 2.0\n"
	"    #define FXAA_QUALITY__P10 4.0\n"
	"    #define FXAA_QUALITY__P11 8.0\n"
	"#endif\n"
	"/*============================================================================\n"
	"                     FXAA QUALITY - EXTREME QUALITY\n"
	"============================================================================*/\n"
	"#if (FXAA_QUALITY__PRESET == 39)\n"
	"    #define FXAA_QUALITY__PS 12\n"
	"    #define FXAA_QUALITY__P0 1.0\n"
	"    #define FXAA_QUALITY__P1 1.0\n"
	"    #define FXAA_QUALITY__P2 1.0\n"
	"    #define FXAA_QUALITY__P3 1.0\n"
	"    #define FXAA_QUALITY__P4 1.0\n"
	"    #define FXAA_QUALITY__P5 1.5\n"
	"    #define FXAA_QUALITY__P6 2.0\n"
	"    #define FXAA_QUALITY__P7 2.0\n"
	"    #define FXAA_QUALITY__P8 2.0\n"
	"    #define FXAA_QUALITY__P9 2.0\n"
	"    #define FXAA_QUALITY__P10 4.0\n"
	"    #define FXAA_QUALITY__P11 8.0\n"
	"#endif\n"
	"/*============================================================================\n"
	"                                API PORTING\n"
	"============================================================================*/\n"
	"#if (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n"
	"    #define FxaaBool bool\n"
	"    #define FxaaDiscard discard\n"
	"    #define FxaaFloat float\n"
	"    #define FxaaFloat2 vec2\n"
	"    #define FxaaFloat3 vec3\n"
	"    #define FxaaFloat4 vec4\n"
	"    #define FxaaHalf float\n"
	"    #define FxaaHalf2 vec2\n"
	"    #define FxaaHalf3 vec3\n"
	"    #define FxaaHalf4 vec4\n"
	"    #define FxaaInt2 ivec2\n"
	"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n"
	"    #define FxaaTex sampler2D\n"
	"#else\n"
	"    #define FxaaBool bool\n"
	"    #define FxaaDiscard clip(-1)\n"
	"    #define FxaaFloat float\n"
	"    #define FxaaFloat2 float2\n"
	"    #define FxaaFloat3 float3\n"
	"    #define FxaaFloat4 float4\n"
	"    #define FxaaHalf half\n"
	"    #define FxaaHalf2 half2\n"
	"    #define FxaaHalf3 half3\n"
	"    #define FxaaHalf4 half4\n"
	"    #define FxaaSat(x) saturate(x)\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_GLSL_120 == 1)\n"
	"    // Requires,\n"
	"    //  #version 120\n"
	"    // And at least,\n"
	"    //  #extension GL_EXT_gpu_shader4 : enable\n"
	"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n"
	"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n"
	"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n"
	"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n"
	"    #else\n"
	"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n"
	"    #endif\n"
	"    #if (FXAA_GATHER4_ALPHA == 1)\n"
	"        // use #extension GL_ARB_gpu_shader5 : enable\n"
	"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n"
	"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n"
	"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n"
	"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n"
	"    #endif\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_GLSL_130 == 1)\n"
	"    // Requires \"#version 130\" or better\n"
	"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n"
	"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n"
	"    #if (FXAA_GATHER4_ALPHA == 1)\n"
	"        // use #extension GL_ARB_gpu_shader5 : enable\n"
	"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n"
	"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n"
	"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n"
	"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n"
	"    #endif\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_HLSL_3 == 1) || (FXAA_360 == 1) || (FXAA_PS3 == 1)\n"
	"    #define FxaaInt2 float2\n"
	"    #define FxaaTex sampler2D\n"
	"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n"
	"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_HLSL_4 == 1)\n"
	"    #define FxaaInt2 int2\n"
	"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
	"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
	"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
	"#endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"#if (FXAA_HLSL_5 == 1)\n"
	"    #define FxaaInt2 int2\n"
	"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
	"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
	"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
	"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n"
	"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n"
	"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n"
	"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n"
	"#endif\n"
	"/*============================================================================\n"
	"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n"
	"============================================================================*/\n"
	"#if (FXAA_GREEN_AS_LUMA == 0)\n"
	"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n"
	"#else\n"
	"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n"
	"#endif    \n"
	"/*============================================================================\n"
	"                             FXAA3 QUALITY - PC\n"
	"============================================================================*/\n"
	"#if (FXAA_PC == 1)\n"
	"/*--------------------------------------------------------------------------*/\n"
	"FxaaFloat4 FxaaPixelShader(\n"
	"    //\n"
	"    // Use noperspective interpolation here (turn off perspective interpolation).\n"
	"    // {xy} = center of pixel\n"
	"    FxaaFloat2 pos,\n"
	"    //\n"
	"    // Used only for FXAA Console, and not used on the 360 version.\n"
	"    // Use noperspective interpolation here (turn off perspective interpolation).\n"
	"    // {xy__} = upper left of pixel\n"
	"    // {__zw} = lower right of pixel\n"
	"    FxaaFloat4 fxaaConsolePosPos,\n"
	"    //\n"
	"    // Input color texture.\n"
	"    // {rgb_} = color in linear or perceptual color space\n"
	"    // if (FXAA_GREEN_AS_LUMA == 0)\n"
	"    //     {___a} = luma in perceptual color space (not linear)\n"
	"    FxaaTex tex,\n"
	"    //\n"
	"    // Only used on the optimized 360 version of FXAA Console.\n"
	"    // For everything but 360, just use the same input here as for \"tex\".\n"
	"    // For 360, same texture, just alias with a 2nd sampler.\n"
	"    // This sampler needs to have an exponent bias of -1.\n"
	"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
	"    //\n"
	"    // Only used on the optimized 360 version of FXAA Console.\n"
	"    // For everything but 360, just use the same input here as for \"tex\".\n"
	"    // For 360, same texture, just alias with a 3nd sampler.\n"
	"    // This sampler needs to have an exponent bias of -2.\n"
	"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
	"    //\n"
	"    // Only used on FXAA Quality.\n"
	"    // This must be from a constant/uniform.\n"
	"    // {x_} = 1.0/screenWidthInPixels\n"
	"    // {_y} = 1.0/screenHeightInPixels\n"
	"    FxaaFloat2 fxaaQualityRcpFrame,\n"
	"    //\n"
	"    // Only used on FXAA Console.\n"
	"    // This must be from a constant/uniform.\n"
	"    // This effects sub-pixel AA quality and inversely sharpness.\n"
	"    //   Where N ranges between,\n"
	"    //     N = 0.50 (default)\n"
	"    //     N = 0.33 (sharper)\n"
	"    // {x___} = -N/screenWidthInPixels  \n"
	"    // {_y__} = -N/screenHeightInPixels\n"
	"    // {__z_} =  N/screenWidthInPixels  \n"
	"    // {___w} =  N/screenHeightInPixels \n"
	"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
	"    //\n"
	"    // Only used on FXAA Console.\n"
	"    // Not used on 360, but used on PS3 and PC.\n"
	"    // This must be from a constant/uniform.\n"
	"    // {x___} = -2.0/screenWidthInPixels  \n"
	"    // {_y__} = -2.0/screenHeightInPixels\n"
	"    // {__z_} =  2.0/screenWidthInPixels  \n"
	"    // {___w} =  2.0/screenHeightInPixels \n"
	"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
	"    //\n"
	"    // Only used on FXAA Console.\n"
	"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n"
	"    // This must be from a constant/uniform.\n"
	"    // {x___} =  8.0/screenWidthInPixels  \n"
	"    // {_y__} =  8.0/screenHeightInPixels\n"
	"    // {__z_} = -4.0/screenWidthInPixels  \n"
	"    // {___w} = -4.0/screenHeightInPixels \n"
	"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
	"    //\n"
	"    // Only used on FXAA Quality.\n"
	"    // This used to be the FXAA_QUALITY__SUBPIX define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // Choose the amount of sub-pixel aliasing removal.\n"
	"    // This can effect sharpness.\n"
	"    //   1.00 - upper limit (softer)\n"
	"    //   0.75 - default amount of filtering\n"
	"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n"
	"    //   0.25 - almost off\n"
	"    //   0.00 - completely off\n"
	"    FxaaFloat fxaaQualitySubpix,\n"
	"    //\n"
	"    // Only used on FXAA Quality.\n"
	"    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // The minimum amount of local contrast required to apply algorithm.\n"
	"    //   0.333 - too little (faster)\n"
	"    //   0.250 - low quality\n"
	"    //   0.166 - default\n"
	"    //   0.125 - high quality \n"
	"    //   0.063 - overkill (slower)\n"
	"    FxaaFloat fxaaQualityEdgeThreshold,\n"
	"    //\n"
	"    // Only used on FXAA Quality.\n"
	"    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD_MIN define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // Trims the algorithm from processing darks.\n"
	"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n"
	"    //   0.0625 - high quality (faster)\n"
	"    //   0.0312 - visible limit (slower)\n"
	"    // Special notes when using FXAA_GREEN_AS_LUMA,\n"
	"    //   Likely want to set this to zero.\n"
	"    //   As colors that are mostly not-green\n"
	"    //   will appear very dark in the green channel!\n"
	"    //   Tune by looking at mostly non-green content,\n"
	"    //   then start at zero and increase until aliasing is a problem.\n"
	"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
	"    // \n"
	"    // Only used on FXAA Console.\n"
	"    // This used to be the FXAA_CONSOLE__EDGE_SHARPNESS define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // This does not effect PS3, as this needs to be compiled in.\n"
	"    //   Use FXAA_CONSOLE__PS3_EDGE_SHARPNESS for PS3.\n"
	"    //   Due to the PS3 being ALU bound,\n"
	"    //   there are only three safe values here: 2 and 4 and 8.\n"
	"    //   These options use the shaders ability to a free *|/ by 2|4|8.\n"
	"    // For all other platforms can be a non-power of two.\n"
	"    //   8.0 is sharper (default!!!)\n"
	"    //   4.0 is softer\n"
	"    //   2.0 is really soft (good only for vector graphics inputs)\n"
	"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
	"    //\n"
	"    // Only used on FXAA Console.\n"
	"    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // This does not effect PS3, as this needs to be compiled in.\n"
	"    //   Use FXAA_CONSOLE__PS3_EDGE_THRESHOLD for PS3.\n"
	"    //   Due to the PS3 being ALU bound,\n"
	"    //   there are only two safe values here: 1/4 and 1/8.\n"
	"    //   These options use the shaders ability to a free *|/ by 2|4|8.\n"
	"    // The console setting has a different mapping than the quality setting.\n"
	"    // Other platforms can use other values.\n"
	"    //   0.125 leaves less aliasing, but is softer (default!!!)\n"
	"    //   0.25 leaves more aliasing, and is sharper\n"
	"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
	"    //\n"
	"    // Only used on FXAA Console.\n"
	"    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD_MIN define.\n"
	"    // It is here now to allow easier tuning.\n"
	"    // Trims the algorithm from processing darks.\n"
	"    // The console setting has a different mapping than the quality setting.\n"
	"    // This only applies when FXAA_EARLY_EXIT is 1.\n"
	"    // This does not apply to PS3, \n"
	"    // PS3 was simplified to avoid more shader instructions.\n"
	"    //   0.06 - faster but more aliasing in darks\n"
	"    //   0.05 - default\n"
	"    //   0.04 - slower and less aliasing in darks\n"
	"    // Special notes when using FXAA_GREEN_AS_LUMA,\n"
	"    //   Likely want to set this to zero.\n"
	"    //   As colors that are mostly not-green\n"
	"    //   will appear very dark in the green channel!\n"
	"    //   Tune by looking at mostly non-green content,\n"
	"    //   then start at zero and increase until aliasing is a problem.\n"
	"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
	"    //    \n"
	"    // Extra constants for 360 FXAA Console only.\n"
	"    // Use zeros or anything else for other platforms.\n"
	"    // These must be in physical constant registers and NOT immedates.\n"
	"    // Immedates will result in compiler un-optimizing.\n"
	"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n"
	"    FxaaFloat4 fxaaConsole360ConstDir\n"
	") {\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat2 posM;\n"
	"    posM.x = pos.x;\n"
	"    posM.y = pos.y;\n"
	"    #if (FXAA_GATHER4_ALPHA == 1)\n"
	"        #if (FXAA_DISCARD == 0)\n"
	"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n"
	"            #if (FXAA_GREEN_AS_LUMA == 0)\n"
	"                #define lumaM rgbyM.w\n"
	"            #else\n"
	"                #define lumaM rgbyM.y\n"
	"            #endif\n"
	"        #endif\n"
	"        #if (FXAA_GREEN_AS_LUMA == 0)\n"
	"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n"
	"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n"
	"        #else\n"
	"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n"
	"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n"
	"        #endif\n"
	"        #if (FXAA_DISCARD == 1)\n"
	"            #define lumaM luma4A.w\n"
	"        #endif\n"
	"        #define lumaE luma4A.z\n"
	"        #define lumaS luma4A.x\n"
	"        #define lumaSE luma4A.y\n"
	"        #define lumaNW luma4B.w\n"
	"        #define lumaN luma4B.z\n"
	"        #define lumaW luma4B.x\n"
	"    #else\n"
	"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n"
	"        #if (FXAA_GREEN_AS_LUMA == 0)\n"
	"            #define lumaM rgbyM.w\n"
	"        #else\n"
	"            #define lumaM rgbyM.y\n"
	"        #endif\n"
	"        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n"
	"    #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat maxSM = max(lumaS, lumaM);\n"
	"    FxaaFloat minSM = min(lumaS, lumaM);\n"
	"    FxaaFloat maxESM = max(lumaE, maxSM);\n"
	"    FxaaFloat minESM = min(lumaE, minSM);\n"
	"    FxaaFloat maxWN = max(lumaN, lumaW);\n"
	"    FxaaFloat minWN = min(lumaN, lumaW);\n"
	"    FxaaFloat rangeMax = max(maxWN, maxESM);\n"
	"    FxaaFloat rangeMin = min(minWN, minESM);\n"
	"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n"
	"    FxaaFloat range = rangeMax - rangeMin;\n"
	"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n"
	"    FxaaBool earlyExit = range < rangeMaxClamped;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    if(earlyExit)\n"
	"        #if (FXAA_DISCARD == 1)\n"
	"            FxaaDiscard;\n"
	"        #else\n"
	"            return rgbyM;\n"
	"        #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    #if (FXAA_GATHER4_ALPHA == 0)\n"
	"        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n"
	"    #else\n"
	"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n"
	"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n"
	"    #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat lumaNS = lumaN + lumaS;\n"
	"    FxaaFloat lumaWE = lumaW + lumaE;\n"
	"    FxaaFloat subpixRcpRange = 1.0/range;\n"
	"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n"
	"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n"
	"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat lumaNESE = lumaNE + lumaSE;\n"
	"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n"
	"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n"
	"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n"
	"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n"
	"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n"
	"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n"
	"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n"
	"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n"
	"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n"
	"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n"
	"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n"
	"    FxaaBool horzSpan = edgeHorz >= edgeVert;\n"
	"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    if(!horzSpan) lumaN = lumaW;\n"
	"    if(!horzSpan) lumaS = lumaE;\n"
	"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n"
	"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat gradientN = lumaN - lumaM;\n"
	"    FxaaFloat gradientS = lumaS - lumaM;\n"
	"    FxaaFloat lumaNN = lumaN + lumaM;\n"
	"    FxaaFloat lumaSS = lumaS + lumaM;\n"
	"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n"
	"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n"
	"    if(pairN) lengthSign = -lengthSign;\n"
	"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat2 posB;\n"
	"    posB.x = posM.x;\n"
	"    posB.y = posM.y;\n"
	"    FxaaFloat2 offNP;\n"
	"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n"
	"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n"
	"    if(!horzSpan) posB.x += lengthSign * 0.5;\n"
	"    if( horzSpan) posB.y += lengthSign * 0.5;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat2 posN;\n"
	"    posN.x = posB.x - offNP.x * FXAA_QUALITY__P0;\n"
	"    posN.y = posB.y - offNP.y * FXAA_QUALITY__P0;\n"
	"    FxaaFloat2 posP;\n"
	"    posP.x = posB.x + offNP.x * FXAA_QUALITY__P0;\n"
	"    posP.y = posB.y + offNP.y * FXAA_QUALITY__P0;\n"
	"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n"
	"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n"
	"    FxaaFloat subpixE = subpixC * subpixC;\n"
	"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    if(!pairN) lumaNN = lumaSS;\n"
	"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n"
	"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n"
	"    FxaaFloat subpixF = subpixD * subpixE;\n"
	"    FxaaBool lumaMLTZero = lumaMM < 0.0;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    lumaEndN -= lumaNN * 0.5;\n"
	"    lumaEndP -= lumaNN * 0.5;\n"
	"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n"
	"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n"
	"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;\n"
	"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;\n"
	"    FxaaBool doneNP = (!doneN) || (!doneP);\n"
	"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;\n"
	"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    if(doneNP) {\n"
	"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"        doneN = abs(lumaEndN) >= gradientScaled;\n"
	"        doneP = abs(lumaEndP) >= gradientScaled;\n"
	"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P2;\n"
	"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P2;\n"
	"        doneNP = (!doneN) || (!doneP);\n"
	"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P2;\n"
	"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P2;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"        #if (FXAA_QUALITY__PS > 3)\n"
	"        if(doneNP) {\n"
	"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"            doneN = abs(lumaEndN) >= gradientScaled;\n"
	"            doneP = abs(lumaEndP) >= gradientScaled;\n"
	"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P3;\n"
	"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P3;\n"
	"            doneNP = (!doneN) || (!doneP);\n"
	"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P3;\n"
	"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P3;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"            #if (FXAA_QUALITY__PS > 4)\n"
	"            if(doneNP) {\n"
	"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P4;\n"
	"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P4;\n"
	"                doneNP = (!doneN) || (!doneP);\n"
	"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P4;\n"
	"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P4;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                #if (FXAA_QUALITY__PS > 5)\n"
	"                if(doneNP) {\n"
	"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                    doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                    doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P5;\n"
	"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P5;\n"
	"                    doneNP = (!doneN) || (!doneP);\n"
	"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P5;\n"
	"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P5;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                    #if (FXAA_QUALITY__PS > 6)\n"
	"                    if(doneNP) {\n"
	"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                        doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                        doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P6;\n"
	"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P6;\n"
	"                        doneNP = (!doneN) || (!doneP);\n"
	"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P6;\n"
	"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P6;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                        #if (FXAA_QUALITY__PS > 7)\n"
	"                        if(doneNP) {\n"
	"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                            doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                            doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P7;\n"
	"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P7;\n"
	"                            doneNP = (!doneN) || (!doneP);\n"
	"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P7;\n"
	"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P7;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    #if (FXAA_QUALITY__PS > 8)\n"
	"    if(doneNP) {\n"
	"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"        doneN = abs(lumaEndN) >= gradientScaled;\n"
	"        doneP = abs(lumaEndP) >= gradientScaled;\n"
	"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P8;\n"
	"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P8;\n"
	"        doneNP = (!doneN) || (!doneP);\n"
	"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P8;\n"
	"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P8;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"        #if (FXAA_QUALITY__PS > 9)\n"
	"        if(doneNP) {\n"
	"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"            doneN = abs(lumaEndN) >= gradientScaled;\n"
	"            doneP = abs(lumaEndP) >= gradientScaled;\n"
	"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P9;\n"
	"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P9;\n"
	"            doneNP = (!doneN) || (!doneP);\n"
	"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P9;\n"
	"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P9;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"            #if (FXAA_QUALITY__PS > 10)\n"
	"            if(doneNP) {\n"
	"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P10;\n"
	"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P10;\n"
	"                doneNP = (!doneN) || (!doneP);\n"
	"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P10;\n"
	"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P10;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                #if (FXAA_QUALITY__PS > 11)\n"
	"                if(doneNP) {\n"
	"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                    doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                    doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;\n"
	"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;\n"
	"                    doneNP = (!doneN) || (!doneP);\n"
	"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;\n"
	"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                    #if (FXAA_QUALITY__PS > 12)\n"
	"                    if(doneNP) {\n"
	"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
	"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
	"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
	"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
	"                        doneN = abs(lumaEndN) >= gradientScaled;\n"
	"                        doneP = abs(lumaEndP) >= gradientScaled;\n"
	"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P12;\n"
	"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P12;\n"
	"                        doneNP = (!doneN) || (!doneP);\n"
	"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P12;\n"
	"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P12;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                    }\n"
	"                    #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                }\n"
	"                #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"            }\n"
	"            #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"        }\n"
	"        #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    }\n"
	"    #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                        }\n"
	"                        #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                    }\n"
	"                    #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"                }\n"
	"                #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"            }\n"
	"            #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"        }\n"
	"        #endif\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    }\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat dstN = posM.x - posN.x;\n"
	"    FxaaFloat dstP = posP.x - posM.x;\n"
	"    if(!horzSpan) dstN = posM.y - posN.y;\n"
	"    if(!horzSpan) dstP = posP.y - posM.y;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n"
	"    FxaaFloat spanLength = (dstP + dstN);\n"
	"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n"
	"    FxaaFloat spanLengthRcp = 1.0/spanLength;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaBool directionN = dstN < dstP;\n"
	"    FxaaFloat dst = min(dstN, dstP);\n"
	"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n"
	"    FxaaFloat subpixG = subpixF * subpixF;\n"
	"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n"
	"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n"
	"/*--------------------------------------------------------------------------*/\n"
	"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n"
	"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n"
	"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n"
	"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n"
	"    #if (FXAA_DISCARD == 1)\n"
	"        return FxaaTexTop(tex, posM);\n"
	"    #else\n"
	"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n"
	"    #endif\n"
	"}\n"
	"/*==========================================================================*/\n"
	"#endif\n"
	"in vec2 pos;\n"
	"uniform sampler2D tex;\n"
	"uniform sampler2D dummy;\n"
	"uniform vec2 pxSize;\n"
	"out vec4 result;\n"
	"void main()\n"
	"{\n"
	"	//vec2 pos;\n"
	"	//sampler2D tex;\n"
	"	//vec2 rcpFrame;\n"
	"	float f = 1.0;\n"
	"	float subpix = 0.75;\n"
	"	float edgeThreshold = 0.1666*f;\n"
	"	float edgeThresholdMin = 0.0833*f;\n"
	"	result = FxaaPixelShader(\n"
	"		pos + pxSize*0.0,\n"
	"		vec4(0.0),\n"
	"		tex,\n"
	"		dummy,\n"
	"		dummy,\n"
	"		pxSize,\n"
	"		vec4(0.0),\n"
	"		vec4(0.0),\n"
	"		vec4(0.0),\n"
	"		subpix,\n"
	"		edgeThreshold,\n"
	"		edgeThresholdMin,\n"
	"		0.0,\n"
	"		0.0,\n"
	"		0.0,\n"
	"		vec4(0.0)\n"
	"	);\n"
	"}\n"
,
	"#version 330\n"
	"in vec2 pos;\n"
	"uniform sampler2D tex;\n"
	"void main()\n"
	"{\n"
	"	gl_FragColor = texture2D(tex, pos);\n"
	"}\n"
,
	"#version 330\n"
	"uniform sampler2D hiResPosTex;\n"
	"uniform sampler2D hiResNormTex;\n"
	"in vec2 pos;\n"
	"uniform vec2 pxSize;\n"
	"void main()\n"
	"{  \n"
	"  vec4 pos_[4];\n"
	"  vec4 norm[4];\n"
	"  vec2 offset = vec2(0.0); // pxSize*vec2(0.25, -0.25)*0.125*0.0; \n"
	"  float scale = 1.0;\n"
	"  pos_[0] = texture2D(hiResPosTex, pos + offset + scale*pxSize*vec2(-0.25, 0.25));\n"
	"  pos_[1] = texture2D(hiResPosTex, pos + offset + scale*pxSize*vec2(0.25, 0.25));\n"
	"  pos_[2] = texture2D(hiResPosTex, pos + offset + scale*pxSize*vec2(0.25, -0.25));\n"
	"  pos_[3] = texture2D(hiResPosTex, pos + offset + scale*pxSize*vec2(-0.25, -0.25));\n"
	"  norm[0] = texture2D(hiResNormTex, pos + offset + scale*pxSize*vec2(-0.25, 0.25));\n"
	"  norm[1] = texture2D(hiResNormTex, pos + offset + scale*pxSize*vec2(0.25, 0.25));\n"
	"  norm[2] = texture2D(hiResNormTex, pos + offset + scale*pxSize*vec2(0.25, -0.25));\n"
	"  norm[3] = texture2D(hiResNormTex, pos + offset + scale*pxSize*vec2(-0.25, -0.25));\n"
	"  float maxZ = max(max(pos_[0].z, pos_[1].z), max(pos_[2].z, pos_[3].z));\n"
	"  float minZ = min(min(pos_[0].z, pos_[1].z), min(pos_[2].z, pos_[3].z));  \n"
	"  int minPos, maxPos;\n"
	"  for (int i = 0; i < 4; ++i)\n"
	"  {\n"
	"	if (pos_[i].z == minZ)\n"
	"	  minPos = i;\n"
	"	if (pos_[i].z == maxZ)\n"
	"	  maxPos = i;\n"
	"  }\n"
	"  float d = distance(pos_[minPos].xyz, pos_[maxPos].xyz);  \n"
	"  ivec2 median = ivec2(0, 0);\n"
	"  int index = 0;\n"
	"  for (int i = 0; i < 4 && index < 2; ++i)    \n"
	"	if (i != minPos && i != maxPos)\n"
	"	  median[index++] = i;\n"
	"  if (d < 1.0)\n"
	"  {\n"
	"	gl_FragData[0] = (pos_[median.x] + pos_[median.y]) / 2.0;\n"
	"	gl_FragData[1] = (norm[median.x] + norm[median.y]) / 2.0;\n"
	"  }\n"
	"  else\n"
	"  {\n"
	"	gl_FragData[0] = pos_[median.x];\n"
	"	gl_FragData[1] = norm[median.x];\n"
	"  }\n"
	"}\n"
,
	"#version 330\n"
	"uniform sampler2D aoTex;\n"
	"uniform sampler2D normTex;\n"
	"uniform sampler2D posTex;\n"
	"in vec2 pos;\n"
	"uniform vec2 pxSize;\n"
	"void main()\n"
	"{\n"
	"  vec3 n = texture2D(normTex, pos).xyz;\n"
	"  vec3 p = texture2D(posTex, pos).xyz;\n"
	"  vec3 ss = vec3(0.0);\n"
	"  float weight = 0.0;\n"
	"  for (float i = -1.0; i <= 1.0; i += 1.0)\n"
	"  {\n"
	"	for (float j = -1.0; j <= 1.0; j += 1.0)\n"
	"	{\n"
	"	  vec2 ij = pxSize*vec2(i, j);\n"
	"	  vec3 t = texture2D(aoTex, pos + ij).xyz;      \n"
	"	  vec3 norm = texture2D(normTex, pos + ij).xyz;\n"
	"	  float depth = texture2D(posTex, pos + ij).z;      \n"
	"	  \n"
	"	  float normWeight = (dot(norm, n) + 1.2) / 2.2;\n"
	"	  normWeight = pow(normWeight, 8.0);\n"
	"	  float depthWeight = 1.0 / (1.0 + abs(p.z - depth) * 0.2);\n"
	"	  depthWeight = pow(depthWeight, 16.0);\n"
	"	  float gaussianWeight = 1.0 / ((abs(i) + 1.0) * (abs(j) + 1.0));\n"
	"	  weight += normWeight * depthWeight * gaussianWeight;\n"
	"	  ss += t * normWeight * depthWeight * gaussianWeight;\n"
	"	}\n"
	"  }\n"
	"  \n"
	"  gl_FragData[0] = vec4(vec3(ss / weight), 0.0);\n"
	"}\n"
,
	"#version 330\n"
	"uniform sampler2D posTex;\n"
	"uniform sampler2D normTex;\n"
	"uniform float dMax;\n"
	"uniform float rMax;\n"
	"uniform float r;\n"
	"//	out vec4 AO;\n"
	"in vec2 pos;\n"
	"uniform vec2 pxSize;\n"
	"vec3 n;\n"
	"vec4 p;\n"
	"float occlusion = 0.0;\n"
	"float sampleCount = 0.0001;\n"
	"void ComputeOcclusion(vec2 xy)\n"
	"{\n"
	"  vec4 samplePos = texture2D(posTex, xy);\n"
	"  vec4 sampleNorm =  texture2D(normTex, xy);\n"
	"  float d = distance(p.xyz, samplePos.xyz);  \n"
	"  float t = min(1.0, (d * d) / (dMax * dMax));  \n"
	"  t = 1.0 - t;  \n"
	"  vec3 diff = normalize(samplePos.xyz - p.xyz);  \n"
	"  float cosTheta = max(dot(n, diff), 0.0);  \n"
	"  occlusion += t * cosTheta * sampleNorm.w;     \n"
	"  sampleCount += 1.0;    \n"
	"}\n"
	"void main()\n"
	"{\n"
	"  n = texture2D(normTex, pos).xyz;\n"
	"  p = texture2D(posTex, pos);\n"
	"//	gl_FragData[0] = vec4(n, 1.0);\n"
	"//	gl_FragData[0] = p;\n"
	"//	return;\n"
	"  float rangeMax = min(r / abs(p.z), rMax);    \n"
	"  for (float x = 1.0; x <= rangeMax; x += 2.0)\n"
	"  {\n"
	"	for (float y = 1.0; y <= rangeMax; y += 2.0)\n"
	"	{\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(x, y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(-x, y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(-x, -y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(x, -y));\n"
	"	}\n"
	"  }\n"
	"  gl_FragData[0] = vec4(occlusion / sampleCount, occlusion, sampleCount, 0.0);//*vec4(1.0, 0.0, 0.0, 1.0);  \n"
	"}\n"
,
	"#version 330\n"
	"uniform sampler2D posTex;\n"
	"uniform sampler2D normTex;\n"
	"uniform sampler2D loResPosTex;\n"
	"uniform sampler2D loResNormTex;\n"
	"uniform sampler2D loResAOTex;\n"
	"uniform float dMax;\n"
	"uniform float rMax;\n"
	"uniform float r;\n"
	"uniform vec2 pxSize;\n"
	"uniform int final;\n"
	"vec3 n;\n"
	"vec4 p;\n"
	"float occlusion = 0.0;\n"
	"float sampleCount = 0.0001;\n"
	"in vec2 pos;\n"
	"void ComputeOcclusion(vec2 xy)\n"
	"{\n"
	"  vec4 samplePos = texture2D(posTex, xy);\n"
	"  vec4 sampleNorm =  texture2D(normTex, xy);\n"
	"  float d = distance(p.xyz, samplePos.xyz);  \n"
	"  float t = min(1.0, (d * d) / (dMax * dMax));  \n"
	"  t = 1.0 - t;  \n"
	"  vec3 diff = normalize(samplePos.xyz - p.xyz);  \n"
	"  float cosTheta = max(dot(n, diff), 0.0);  \n"
	"  occlusion += t * cosTheta * sampleNorm.w;      \n"
	"  sampleCount += 1.0;    \n"
	"}\n"
	"vec3 Upsample()\n"
	"{\n"
	"  vec2 loResCoord[4];\n"
	"/*	  loResCoord[0] = pos + pxSize*vec2(-1.0,  1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);    \n"
	"  loResCoord[1] = pos + pxSize*vec2( 1.0,  1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);\n"
	"  loResCoord[2] = pos + pxSize*vec2(-1.0, -1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);\n"
	"  loResCoord[3] = pos + pxSize*vec2( 1.0, -1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);*/\n"
	"  \n"
	"/*	  loResCoord[0] = pos;// + pxSize*vec2(-1.0,  1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);    \n"
	"  loResCoord[1] = pos;// + pxSize*vec2( 1.0,  1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);\n"
	"  loResCoord[2] = pos;// + pxSize*vec2(-1.0, -1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);\n"
	"  loResCoord[3] = pos;// + pxSize*vec2( 1.0, -1.0) / 2.0;// + pxSize*vec2(0.5, 0.5);\n"
	"*/\n"
	"loResCoord[0] = pxSize*(floor((pos/pxSize + vec2(-1.0,  1.0)) / 2.0)*2.0 + vec2(0.5, 0.5));\n"
	"loResCoord[1] = pxSize*(floor((pos/pxSize + vec2( 1.0,  1.0)) / 2.0)*2.0 + vec2(0.5, 0.5));\n"
	"loResCoord[2] = pxSize*(floor((pos/pxSize + vec2(-1.0, -1.0)) / 2.0)*2.0 + vec2(0.5, 0.5));\n"
	"loResCoord[3] = pxSize*(floor((pos/pxSize + vec2( 1.0, -1.0)) / 2.0)*2.0 + vec2(0.5, 0.5));\n"
	"  vec3 loResAO[4];\n"
	"  vec3 loResNorm[4];\n"
	"  float loResDepth[4];\n"
	"  for (int i = 0; i < 4; ++i)\n"
	"  {\n"
	"	loResNorm[i] = texture2D(loResNormTex, loResCoord[i]).xyz;\n"
	"	loResDepth[i] = texture2D(loResPosTex, loResCoord[i]).z;\n"
	"	loResAO[i] = texture2D(loResAOTex, loResCoord[i]).xyz;\n"
	"  }      \n"
	"  float normWeight[4];\n"
	"  for (int i = 0; i < 4; ++i)\n"
	"  {    \n"
	"	normWeight[i] = (dot(loResNorm[i], n) + 1.1) / 2.1;\n"
	"	normWeight[i] = pow(normWeight[i], 8.0);\n"
	"  }    \n"
	"  float depthWeight[4];\n"
	"  for (int i = 0; i < 4; ++i)\n"
	"  {\n"
	"	depthWeight[i] = 1.0 / (1.0 + abs(p.z - loResDepth[i]) * 0.2);\n"
	"	depthWeight[i] = pow(depthWeight[i], 16.0);\n"
	"  }       \n"
	"  float totalWeight = 0.0;\n"
	"  vec3 combinedAO = vec3(0.0);\n"
	"  for (int i = 0; i < 4; ++i)\n"
	"  {\n"
	"	float weight = normWeight[i] * depthWeight[i] * (9.0 / 16.0) /\n"
	"	  (abs((pos.x - loResCoord[i].x * 2.0) * (pos.y - loResCoord[i].y * 2.0)) * 4.0);     // wonder if this works well enough  \n"
	"	totalWeight += weight;\n"
	"	combinedAO += loResAO[i] * weight;    \n"
	"  }\n"
	"  combinedAO /= totalWeight;  \n"
	"  return combinedAO;\n"
	"}\n"
	"void main()\n"
	"{\n"
	"  n = texture2D(normTex, pos).xyz;\n"
	"  p = texture2D(posTex, pos);\n"
	"  float rangeMax = min(r / abs(p.z), rMax);\n"
	"  for (float x = 1.0; x <= rangeMax; x += 2.0)\n"
	"  {\n"
	"	for (float y = 1.0; y <= rangeMax; y += 2.0)\n"
	"	{\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(x, y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(-x, y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(-x, -y));\n"
	"	  ComputeOcclusion(pos + pxSize*vec2(x, -y));\n"
	"	}\n"
	"  }\n"
	"  vec3 upsample = Upsample();\n"
	"  if (final==1)\n"
	"  {\n"
	"    float aoMax = max(upsample.x, occlusion / sampleCount);  \n"
	"    float aoAverage = (upsample.y + occlusion) / (upsample.z + sampleCount);\n"
	"    float currentFrameAO = (1.0 - aoMax) * (1.0 - aoAverage); \n"
	"//		gl_FragData[0] = vec4(vec3((0.5*(1.0-dot(n, vec3(0.0, 0.0, 1.0))))), 1.0);\n"
	"//		gl_FragData[0] = vec4(vec3(currentFrameAO*(0.5+0.5*(1.0-dot(n, vec3(0.0, 0.0, 1.0))))), 1.0);\n"
	"//		gl_FragData[0] = vec4(vec3(currentFrameAO)*0.8, 1.0);\n"
	"		gl_FragData[0] = vec4(vec3(currentFrameAO), 1.0);\n"
	"  }\n"
	"  else\n"
	"  {  \n"
	"    gl_FragData[0] = vec4(max(upsample.x, occlusion / sampleCount), upsample.y + occlusion, upsample.z + sampleCount, 0.0);//*vec4(2.0, 0.0, 0.0, 0.0); \n"
	"  }  \n"
	"//	  gl_FragData[0] = vec4(upsample.x, upsample.y, upsample.z, 0.0); \n"
	"}\n"
,
};

uint32_t g_embeddableShaderCount = 36;
